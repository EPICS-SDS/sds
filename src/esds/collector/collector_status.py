from collections import deque
from datetime import UTC, datetime
from typing import Dict, Optional

from pydantic import BaseModel

from esds.collector.config import settings
from esds.common.files import WriteResult
from esds.common.schemas import CollectorBase


class Settings:
    def __init__(self):
        self.collectors: Dict[str, CollectorBase] = dict()


class PvStatusSchema(BaseModel):
    name: str
    last_event: Optional[datetime] = None
    last_event_id: Optional[int] = 0
    connected: bool = False
    last_event_size: float = 0
    avg_event_size: float = 0
    # Number of PV updates received successfully
    successful_updates: int = 0
    # Number of PV updates that came with a duplicated Cycle ID
    duplicated_cycle_id: int = 0


class CollectorBasicStatus(BaseModel):
    collector_id: str
    name: str
    parent_path: str
    running: bool = False
    # Timestamp of the SDS event that triggered the last collection
    last_collection: Optional[datetime] = None
    # Cycle ID of the SDS event that triggered the last collection
    last_collection_id: Optional[int] = None
    # Time it takes to collect all PVs for one event. It should sufficiently lower than the `collector_timeout` setting.
    avg_collection_time: float = 0
    last_collection_time: float = 0
    # Average file size generated by this collector
    avg_collection_size: float = 0
    last_collection_size: float = 0
    # Number of PV updates received successfully
    total_successful_updates: int = 0
    # Number of PV updates that came with a duplicated Cycle ID
    total_duplicated_cycle_id: int = 0


class CollectorFullStatus(CollectorBasicStatus):
    pvs: Dict[str, PvStatusSchema]


class CollectorStatus(CollectorFullStatus):
    collection_time_queue: deque[float] = deque(maxlen=settings.status_queue_length)
    collection_size_queue: deque[float] = deque(maxlen=settings.status_queue_length)


class PvStatus:
    def __init__(self, name: str):
        self.event_timestamps: datetime
        self.event_size: deque[float] = deque(maxlen=settings.status_queue_length)
        self.pv_status = PvStatusSchema(name=name)
        self.successful_updates: Dict[int, int] = dict()
        self.duplicated_cycle_id: Dict[int, int] = dict()

    def set_last_event(self, last_event: datetime, last_event_id: int):
        self.pv_status.last_event = last_event
        self.pv_status.last_event_id = last_event_id
        if last_event is not None:
            self.event_timestamps = last_event

    def set_event_size(self, size: float):
        self.event_size.append(size)
        self.pv_status.avg_event_size = sum(self.event_size) / len(self.event_size)
        self.pv_status.last_event_size = size

    def update_written_data(self, write_result: WriteResult, sds_event_cycle_id: int):
        if sds_event_cycle_id not in self.successful_updates:
            self.successful_updates.update({sds_event_cycle_id: 0})
        if sds_event_cycle_id not in self.duplicated_cycle_id:
            self.duplicated_cycle_id.update({sds_event_cycle_id: 0})

        self.successful_updates[sds_event_cycle_id] += write_result.successful
        self.duplicated_cycle_id[sds_event_cycle_id] += write_result.duplicated

        self.pv_status.successful_updates = self.successful_updates[sds_event_cycle_id]
        self.pv_status.duplicated_cycle_id = self.duplicated_cycle_id[
            sds_event_cycle_id
        ]


class StatusManager:
    def __init__(self):
        self.collector_status_dict: Dict[str, CollectorStatus] = dict()
        self.pv_status_dict: Dict[str, Dict[str, PvStatus]] = dict()

    def add_collector(self, collector: CollectorBase):
        pv_status_dict: Dict[str, PvStatusSchema] = dict()

        for pv in collector.pvs:
            if pv not in self.pv_status_dict.keys():
                self.pv_status_dict[pv] = dict()

            pv_status = PvStatus(name=pv)
            pv_status_dict.update({pv: pv_status.pv_status})
            self.pv_status_dict[pv][collector.collector_id] = pv_status

        self.collector_status_dict.update(
            {
                collector.collector_id: CollectorStatus(
                    collector_id=collector.collector_id,
                    name=collector.name,
                    parent_path=collector.parent_path,
                    running=False,
                    pvs=pv_status_dict,
                )
            }
        )

    def remove_collector(self, collector_id: str):
        collector_rm = self.collector_status_dict.pop(collector_id)

        for pv in collector_rm.pvs:
            self.pv_status_dict[pv].pop(collector_id)
            if self.pv_status_dict[pv] == []:
                self.pv_status_dict.pop(pv)

    def set_pv_connected(self, pv: str, connected: bool) -> None:
        for pv_status in self.pv_status_dict[pv].values():
            pv_status.pv_status.connected = connected

    def remove_sds_cycle(self, collector_id: str, sds_event_cycle_id: int):
        """
        Updates the collector status information after the collector has finished processing an SDS event and removes all the buffered data related to that SDS cycle ID.
        """
        collector_status = self.collector_status_dict[collector_id]
        collector_status.total_successful_updates = 0
        collector_status.total_duplicated_cycle_id = 0

        for pv in self.collector_status_dict[collector_id].pvs:
            pv_status = self.pv_status_dict[pv][collector_id]
            if sds_event_cycle_id in pv_status.successful_updates:
                successful_updates = pv_status.successful_updates.pop(
                    sds_event_cycle_id
                )
                collector_status.total_successful_updates += successful_updates
            if sds_event_cycle_id in pv_status.duplicated_cycle_id:
                duplicated_cycle_id = pv_status.duplicated_cycle_id.pop(
                    sds_event_cycle_id
                )
                collector_status.total_duplicated_cycle_id += duplicated_cycle_id

    def update_written_data(
        self,
        write_result: Dict[str, WriteResult],
        collector_id: str,
        sds_event_cycle_id: int,
    ):
        for pv in write_result:
            pv_status = self.pv_status_dict[pv][collector_id]
            pv_status.update_written_data(write_result[pv], sds_event_cycle_id)

    def set_update_event(self, collector_id: str, pv: str, sds_event_cycle_id: int):
        self.pv_status_dict[pv][collector_id].set_last_event(
            datetime.now(UTC), sds_event_cycle_id
        )

    def set_event_size(self, collector_id: str, pv: str, size: float):
        self.pv_status_dict[pv][collector_id].set_event_size(size)

    def set_collector_running(self, collector_id: str, running: bool):
        collector = self.collector_status_dict.get(collector_id)
        collector.running = running

    def set_last_collection(self, collector_id: str, sds_event_cycle_id: int):
        collector = self.collector_status_dict.get(collector_id)
        collector.last_collection = datetime.now(UTC)
        collector.last_collection_id = sds_event_cycle_id

    def set_collection_time(self, collector_id: str, collection_time: float):
        collector = self.collector_status_dict.get(collector_id)
        collector.collection_time_queue.append(collection_time)
        collector.avg_collection_time = sum(collector.collection_time_queue) / len(
            collector.collection_time_queue
        )
        collector.last_collection_time = collection_time

    def set_collection_size(self, collector_id: str, collection_size: float):
        collector = self.collector_status_dict.get(collector_id)
        collector.collection_size_queue.append(collection_size)
        collector.avg_collection_size = sum(collector.collection_size_queue) / len(
            collector.collection_size_queue
        )
        collector.last_collection_size = collection_size
